.pio_version 0 // only requires PIO version 0
.program pmemtest
; Note: We need to update the address lines and the RAS# at the same time.
    jmp begin
full_transfer:
    out pins, 8       ; Load row address
    set pins, 0b110   ; Lower RAS#
    nop [2]           ; 26.5ns total = tRCD
cas_only_transfer:
    out pins, 9       ; Load col address + write data
    jmp !x skip_wr
    set pins, 0b000   ; Lower CAS#, WR#
    jmp skip_wr2
skip_wr:
    set pins, 0b100   ; Lower CAS#
skip_wr2:
    mov OSR, NULL [1] ; 19.8ns. Clear OSR
    nop [2]           ; 39.6ns total = tCAH, tDH, tWCH
    set pins, 0b100   ; Raise WR#
    out pins, 9       ; 46.2ns. Clear addr+data
    nop [3]           ; 72.9ns total = tRSH, tRSH
    in pins, 1        ; Get the pin state here (ideally 80ns after CAS falls, tCAC)
    set pins, 0b110   ; Raise CAS#
    push noblock
    nop [2]           ; 98.9ns
    jmp !y begin      ; Raise RAS# only if we are doing a full transfer
    jmp skip_ras
begin:
    set pins, 0b111   ; 105.5ns, raise RAS#
skip_ras:
    nop [24]          ; 270.5ns
    pull block        ; Wait for new data to arrive
    out y, 1          ; get first bit which tells us if this is fast page mode
    out x, 1          ; get second bit which tells us if we are in write mode.
    jmp !y full_transfer
    out NULL, 8           ; Throw out row address
    jmp cas_only_transfer ; Fast page mode


% c-sdk {
static inline void pmemtest_program_init(PIO pio, uint sm, uint offset, uint pin) {
    uint count;

    // 13 outputs
    for (count = 0; count < 13; count++) {
        pio_gpio_init(pio, pin + count);
        gpio_set_slew_rate(pin + count, GPIO_SLEW_RATE_FAST);
        gpio_set_drive_strength(pin + count, GPIO_DRIVE_STRENGTH_4MA);
    }
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 13, true); // true=output
    pio_sm_set_consecutive_pindirs(pio, sm, pin + 12, 1, false); // input

    pio_sm_set_clkdiv(pio, sm, 1); // should just be the default.

    pio_sm_config c = pmemtest_program_get_default_config(offset);
// A0, A1, A2, A3, A4, A5, A6, A7, D, RAS, CAS, WR, IN
    sm_config_set_out_pins(&c, pin, 9);
    sm_config_set_set_pins(&c, pin + 9, 3); // Max is 5.
    sm_config_set_sideset_pins(&c, pin + 9);
    sm_config_set_in_pins(&c, pin + 12);

    // Shift right, Autopull off, 19 bits (1 + 1 + 8 + 9) at a time
    sm_config_set_out_shift(&c, true, false, 19);
    // Shift left, Autopull on, 1 bit
    sm_config_set_in_shift(&c, false, false, 1);

 //   hw_set_bits(&pio->input_sync_bypass, 1u << pin); to bypass synchronization on an input
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
