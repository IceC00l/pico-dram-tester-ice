.pio_version 0 // only requires PIO version 0
.program pmemtest

.side_set 4
.wrap_target
;    mov OSR, ~NULL side 0
;    wait 1 pin 0 side 0; pin 0 is actually pin+1 since in group is relative
;    out pins, 8 side 1
;    set pins, 1 side 1
;    mov OSR, NULL side 1
;    wait 0 pin 0 side 1
;    out pins, 1 side 0
;    set pins, 0 side 0

; Note: We need to update the address lines and the RAS# at the same time.
    pull block        side 0b0111 ; blocks with RAS#, CAS#, and WE# high.
    out pins, 8       side 0b0110 ; Lower RAS# and load row address
    nop [1]           side 0b0110     ; 19.8ns
    nop               side 0b0110         ; 26.4ns total = tRCD
    out pins, 9       side 0b0000 ; Lower CAS#, WR#, load col address + write data
    mov OSR, NULL [1] side 0b0000 ; 19.8ns. Clear OSR
    nop [1]           side 0b0000 ; 33ns
    nop               side 0b0000 ; 39.6ns total = tCAH, tDH, tWCH
    out pins, 9       side 0b0100 ; 46.2ns. Clear addr+data and raise WR#
    nop [1]           side 0b0100 ; 59.4ns.
    nop [1]           side 0b0100 ; 72.6ns.
    nop               side 0b0100 ; 79.2ns total = tRSH, tRSH
    nop               side 0b0110 ; 85.8ns, raise CAS#
    nop [1]           side 0b0110 ; 98.9ns.
    nop               side 0b0111 ; 105.5ns, raise RAS#
    set x, 24         side 0b0111 ; 112.1ns. Load 24*6.6ns delay
loop:
    jmp x--, loop     side 0b0111 ; 270.5ns.
.wrap

% c-sdk {
static inline void pmemtest_program_init(PIO pio, uint sm, uint offset, uint pin) {
    uint count;

    // 13 outputs
    for (count = 0; count < 13; count++) {
        pio_gpio_init(pio, pin + count);
        gpio_set_slew_rate(pin + count, GPIO_SLEW_RATE_FAST);
        gpio_set_drive_strength(pin + count, GPIO_DRIVE_STRENGTH_4MA);
    }
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 13, true); // true=output

    pio_sm_set_clkdiv(pio, sm, 1); // should just be the default.

    pio_sm_config c = pmemtest_program_get_default_config(offset);
    sm_config_set_out_pins(&c, pin, 9);
//    sm_config_set_set_pins(&c, pin + 9, 1);
    sm_config_set_sideset_pins(&c, pin + 9);
//    sm_config_set_in_pins(&c, pin);

    // Shift right, Autopull off, 17 bits (8 + 8 + 1) at a time
    sm_config_set_out_shift(&c, true, false, 17);

 //   hw_set_bits(&pio->input_sync_bypass, 1u << pin); to bypass synchronization on an input
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
