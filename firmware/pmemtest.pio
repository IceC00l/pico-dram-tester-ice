;
; 4164 Test Program
;

; Pin Assignments
; SP0  = A0
; SP1  = A1
; SP2  = A2
; SP3  = A3
; SP4  = A4
; SP5  = A5
; SP6  = A6
; SP7  = A7
; SP8  = nc
; SP9  = D
; SP10 = WE#
; SP11 = RAS#
; SP12 = CAS#
; SP13 = nc
; SP14 = nc
; SP15 = nc
; SP16 = Q

; Timing values (nameplate, tRAC): 100ns, 120ns, 150ns, 200ns, 300ns

; set pins: CAS, RAS, WR.
.pio_version 0 // only requires PIO version 0
.program pmemtest
; Note: We need to update the address lines and the RAS# at the same time.
    jmp begin
full_transfer:        ; (delay val at end of instr)
    nop [1]          ; 264.0 [27] tRC = 260.7ns
    out pins, 8       ; 3.3    Load row address
    set pins, 0b101   ; 6.6    Lower RAS#
    nop [2]           ; 26.4   [5] tRCD (RAS to CAS) = 26.4ns
cas_only_transfer:
    out pins, 10      ; 29.7     Load col address + write data
    jmp !x skip_wr    ; 33
    set pins, 0b000   ; 36.3     Lower CAS#, WR#
    jmp skip_wr2      ; 39.6
skip_wr:
    set pins, 0b001   ; 36.3     Lower CAS#
    nop               ; 39.6
skip_wr2:
    mov OSR, NULL     ; 42.9     Clear OSR
    nop [3]           ; 56.1     [3]
    set pins, 0b001   ; 59.4     Raise WR#  tWCH = 26.4ns.
    out pins, 10      ; 62.7     Clear addr+data. tCAH, tDH = 29.7ns.
    nop [4]          ; 108.9    [13] total = tRSH, tRSH
    in pins, 1        ; 112.2    Get bit tCAC = 75.9ns
    set pins, 0b101   ; 115.5    Raise CAS#. tCAS = 79.2ns
    push noblock      ; 118.8
    nop [5]           ; 151.8    [9]
    jmp !y begin      ; 155.1 Raise RAS# only if we are doing a full transfer
    jmp skip_ras      ; 158.4
begin:
    set pins, 0b111   ; 158.4 raise RAS#. tRAS=151.8ns
skip_ras:
    pull block        ; 161.7 Wait for new data to arrive
    out y, 1          ; 165.0 get first bit which tells us if this is fast page mode
    out x, 1          ; 168.3 get second bit which tells us if we are in write mode.
    jmp !y full_transfer ; 171.6
    out NULL, 8           ; 174.9 Throw out row address
    jmp cas_only_transfer ; 178.2 Fast page mode tCP=22*3.3=72.6ns


% c-sdk {

static const uint8_t pmemtest_delays[] = {0, 27, 5, 3, 13, 9};

static inline void pmemtest_program_init(PIO pio, uint sm, uint offset, uint pin) {
    uint count;

    // Set up 17 total pins
    for (count = 0; count < 17; count++) {
        pio_gpio_init(pio, pin + count);
        gpio_set_slew_rate(pin + count, GPIO_SLEW_RATE_FAST);
        gpio_set_drive_strength(pin + count, GPIO_DRIVE_STRENGTH_4MA);
    }
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 13, true); // true=output
    pio_sm_set_consecutive_pindirs(pio, sm, pin + 16, 1, false); // input

    pio_sm_set_clkdiv(pio, sm, 1); // should just be the default.

    pio_sm_config c = pmemtest_program_get_default_config(offset);
// A0, A1, A2, A3, A4, A5, A6, A7, nc, D, WR, RAS, CAS, nc, nc, nc, IN
    sm_config_set_out_pins(&c, pin, 10);
    sm_config_set_set_pins(&c, pin + 10, 3); // Max is 5.
//    sm_config_set_sideset_pins(&c, pin + 9);
    sm_config_set_in_pins(&c, pin + 16);

    // Shift right, Autopull off, 20 bits (1 + 1 + 8 + 10) at a time
    sm_config_set_out_shift(&c, true, false, 20);
    // Shift left, Autopull on, 1 bit
    sm_config_set_in_shift(&c, false, false, 1);

 //   hw_set_bits(&pio->input_sync_bypass, 1u << pin); to bypass synchronization on an input
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
